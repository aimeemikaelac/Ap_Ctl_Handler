// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.1
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================

#include "ap_ctl_handler.h"
#include "SysCFileHandler.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;

#define AUTOTB_DUT      ap_ctl_handler
#define AUTOTB_DUT_INST AESL_inst_ap_ctl_handler
#define AUTOTB_TOP      apatb_ap_ctl_handler_top
#define AUTOTB_LAT_RESULT_FILE "ap_ctl_handler.result.lat.rb"
#define AUTOTB_PER_RESULT_TRANS_FILE "ap_ctl_handler.performance.result.transaction.xml"
#define AUTOTB_TOP_INST AESL_inst_apatb_ap_ctl_handler_top
#define AUTOTB_TRANSACTION_NUM  1
#define AUTOTB_TVIN     "ap_ctl_handler.autotvin.dat"
#define AUTOTB_TVOUT    "ap_ctl_handler.autotvout.dat"
#define AUTOTB_HDL_TVIN "ap_ctl_handler.hdltvin.dat"
#define AUTOTB_HDL_TVOUT "ap_ctl_handler.hdltvout.dat"
#define LENGTH_ap_start_out 1
#define LENGTH_ap_ready_in 1
#define LENGTH_ap_done_in 1
#define LENGTH_ap_idle_in 1

#define REF_TCL_FILE "../tv/cdatafile/ref.tcl"
#define AUTOTB_TVIN_ap_ready_in  "../tv/cdatafile/c.ap_ctl_handler.autotvin_ap_ready_in.dat"
#define AUTOTB_TVIN_ap_done_in  "../tv/cdatafile/c.ap_ctl_handler.autotvin_ap_done_in.dat"
#define AUTOTB_TVIN_ap_idle_in  "../tv/cdatafile/c.ap_ctl_handler.autotvin_ap_idle_in.dat"
#define AUTOTB_TVIN_ap_ready_in_out_wrapc  "../tv/rtldatafile/rtl.ap_ctl_handler.autotvin_ap_ready_in.dat"
#define AUTOTB_TVIN_ap_done_in_out_wrapc  "../tv/rtldatafile/rtl.ap_ctl_handler.autotvin_ap_done_in.dat"
#define AUTOTB_TVIN_ap_idle_in_out_wrapc  "../tv/rtldatafile/rtl.ap_ctl_handler.autotvin_ap_idle_in.dat"
#define AUTOTB_TVOUT_ap_start_out  "../tv/cdatafile/c.ap_ctl_handler.autotvout_ap_start_out.dat"
#define AUTOTB_TVOUT_ap_start_out_out_wrapc  "../tv/rtldatafile/rtl.ap_ctl_handler.autotvout_ap_start_out.dat"


SC_MODULE(AUTOTB_TOP)
{
#if defined(AESL_APATB_ALDEC)
    sc_in< sc_logic > AESL_clock;
    sc_signal< bool > AESL_clock_bool;
#endif
#if !defined(AESL_APATB_ALDEC)
    sc_in_clk AESL_clock;
#endif
    sc_signal< sc_logic > AESL_reset;
    sc_signal< sc_logic > AESL_start;
    sc_signal< sc_logic > AESL_ce;
    sc_signal< sc_logic > AESL_idle;
    sc_signal< sc_logic > AESL_done;
    sc_signal< sc_logic > AESL_ready;
    sc_signal< sc_logic > AESL_continue;
    sc_signal< sc_logic > AESL_transaction_ready;
    sc_signal< sc_logic > AESL_interface_done;
    sc_signal< sc_logic > AESL_transaction_ready_ap_start_enable;
    sc_signal< sc_logic > AESL_transaction_done_ap_start_enable;
    sc_signal< sc_logic > AESL_transaction_ready_ap_start_out;
    sc_signal< sc_logic > AESL_transaction_done_ap_start_out;
    sc_signal< sc_logic > AESL_transaction_ready_ap_ready_in;
    sc_signal< sc_logic > AESL_transaction_done_ap_ready_in;
    sc_signal< sc_logic > AESL_transaction_ready_ap_done_in;
    sc_signal< sc_logic > AESL_transaction_done_ap_done_in;
    sc_signal< sc_logic > AESL_transaction_ready_ap_idle_in;
    sc_signal< sc_logic > AESL_transaction_done_ap_idle_in;
    sc_signal< sc_logic > AESL_transaction_ready_ap_status_out_V;
    sc_signal< sc_logic > AESL_transaction_done_ap_status_out_V;
    sc_signal< sc_logic > AESL_ready_delay;
    sc_signal< sc_logic > AESL_done_delay;
    sc_signal< sc_logic > AESL_done_delay2;
    sc_signal< sc_logic > AESL_initial_ready;

    sc_signal< sc_logic > ap_start_enable;
    sc_signal< sc_logic > ap_start_out;
    sc_signal< sc_logic > AESL_BUFF_ap_start_out;
    std::vector< sc_logic > ap_start_out_output_vector;
    int ap_start_out_counter;
    sc_signal< sc_logic > ap_ready_in;
    sc_signal< sc_logic > ap_done_in;
    sc_signal< sc_logic > ap_idle_in;
    sc_signal< sc_lv<3> > ap_status_out_V;

    AUTOTB_DUT * AUTOTB_DUT_INST;



AESL_FILE_HANDLER AESL_fh;
    ifstream AESL_mTvIn;
    ifstream AESL_mTvOut;
    ofstream AESL_mHdlTvIn;
    ofstream AESL_mHdlTvOut;
    int AESL_mErrNo;
    int AESL_mTransNo;
    ofstream AESL_mErrLog;
    ofstream AESL_mParamLog;

    int AESL_mLatCnter;
    int AESL_mLatCnterInIdx;
    int* AESL_mLatCnterIn;
    int* AESL_mLatCnterOut;
    int* AESL_lat_array;
    int* AESL_thr_array;
    int AESL_mLatCnterOutIdx;
    int AESL_done_cnt;
    int AESL_ready_cnt;

    bool AESL_mFinishTvOut_ap_start_out;


    void AESL_proc_tv_in();
    void AESL_proc_transaction_ready();
    void AESL_proc_interface_done();
    void AESL_proc_transaction_ready_ap_start_enable();
    void AESL_proc_transaction_done_ap_start_enable();
    void AESL_proc_transaction_ready_ap_start_out();
    void AESL_proc_transaction_done_ap_start_out();
    void AESL_proc_transaction_ready_ap_ready_in();
    void AESL_proc_transaction_done_ap_ready_in();
    void AESL_proc_transaction_ready_ap_done_in();
    void AESL_proc_transaction_done_ap_done_in();
    void AESL_proc_transaction_ready_ap_idle_in();
    void AESL_proc_transaction_done_ap_idle_in();
    void AESL_proc_transaction_ready_ap_status_out_V();
    void AESL_proc_transaction_done_ap_status_out_V();
    void AESL_proc_ready_delay();
    void AESL_proc_done_delay();
    void AESL_proc_initial_ready();
    void AESL_proc_ready_cnt();
    void AESL_proc_tv_out();
    void AESL_proc_mlatcnterin();
    void AESL_proc_mlatcnterout();
    void AESL_proc_calculate_performance();
    void AESL_proc_tv_in_ap_ready_in();
    void AESL_proc_tv_in_ap_done_in();
    void AESL_proc_tv_in_ap_idle_in();
    void AESL_proc_tv_out_ap_start_out();
    void AESL_proc_cnter();
    bool AESL_proc_split_tv();
    void AESL_proc_buffer_output();

#if defined(AESL_APATB_ALDEC)
    void AESL_proc_clock_bool() {
        if (AESL_clock.read() == SC_LOGIC_1)
            AESL_clock_bool.write(true);
        else
            AESL_clock_bool.write(false);
    }
#endif



    ~AUTOTB_TOP()
    {
        if (AESL_mErrNo != 0) {
            AESL_mErrLog << "AESL_mErrNo = " << AESL_mErrNo << endl;
        }
        AESL_mErrLog.close();
        AESL_mParamLog.close();
        AESL_mTvIn.close();
        AESL_mTvOut.close();
        AESL_mHdlTvIn.close();
        AESL_mHdlTvOut.close();
        delete AESL_mLatCnterIn;
        delete AESL_mLatCnterOut;
        delete AESL_lat_array;
        delete AESL_thr_array;
        delete AUTOTB_DUT_INST;
    }

    SC_CTOR(AUTOTB_TOP)
    {
        AESL_mErrNo = 0;
        AESL_mTransNo = AUTOTB_TRANSACTION_NUM;
        AESL_mErrLog.open("err.log");
        AESL_mParamLog.open("param.log");
        AESL_mLatCnterIn    = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_mLatCnterOut   = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_lat_array      = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_thr_array      = new int[AUTOTB_TRANSACTION_NUM + 1];


        AESL_mLatCnter = 0;
        AESL_mLatCnterInIdx = 0;
        AESL_mLatCnterOutIdx = 0;
        AESL_done_cnt = 0;

        ap_start_out_counter = -1;
        AESL_mFinishTvOut_ap_start_out = false;

        AESL_mHdlTvIn.open(AUTOTB_HDL_TVIN);
        AESL_mHdlTvOut.open(AUTOTB_HDL_TVOUT);

        if (!AESL_mHdlTvIn.good()
            || !AESL_mHdlTvOut.good()
        ) {
            AESL_mErrNo = 1;
            sc_stop();
            return;
        }
    
        AUTOTB_DUT_INST = new AUTOTB_DUT("AUTOTB_DUT_INST");
        AUTOTB_DUT_INST->ap_start( AESL_start );
        AUTOTB_DUT_INST->ap_done( AESL_done );
        AUTOTB_DUT_INST->ap_idle( AESL_idle );
        AUTOTB_DUT_INST->ap_ready( AESL_ready );
        AUTOTB_DUT_INST->ap_start_enable( ap_start_enable );
        AUTOTB_DUT_INST->ap_start_out( ap_start_out );
        AUTOTB_DUT_INST->ap_ready_in( ap_ready_in );
        AUTOTB_DUT_INST->ap_done_in( ap_done_in );
        AUTOTB_DUT_INST->ap_idle_in( ap_idle_in );
        AUTOTB_DUT_INST->ap_status_out_V( ap_status_out_V );
        AUTOTB_DUT_INST->ap_virtual_clock( AESL_clock);

        SC_METHOD(AESL_proc_transaction_ready_ap_start_enable);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_ap_start_enable);
        sensitive << AESL_done_delay;


        SC_METHOD(AESL_proc_transaction_done_ap_start_out);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_ap_ready_in);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_ap_ready_in);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_ap_done_in);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_ap_done_in);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_ap_idle_in);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_ap_idle_in);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_ap_status_out_V);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_ready_delay);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_METHOD(AESL_proc_done_delay);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_THREAD(AESL_proc_interface_done);
        sensitive << AESL_clock.pos();

        SC_METHOD(AESL_proc_transaction_ready);
        sensitive << AESL_initial_ready << AESL_done_delay;

        SC_THREAD(AESL_proc_initial_ready);
        sensitive << AESL_clock.pos();

        SC_METHOD(AESL_proc_ready_cnt);
        sensitive << AESL_transaction_ready;

        SC_THREAD(AESL_proc_tv_in);
        sensitive << AESL_clock.pos();

        SC_THREAD(AESL_proc_tv_out);
        sensitive << AESL_clock.pos();

        SC_METHOD(AESL_proc_mlatcnterin);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_METHOD(AESL_proc_mlatcnterout);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_THREAD(AESL_proc_calculate_performance);
        sensitive << AESL_clock.pos();

        SC_THREAD(AESL_proc_tv_in_ap_ready_in);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_ap_done_in);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_ap_idle_in);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_out_ap_start_out);
         sensitive << AESL_clock.pos();


        SC_METHOD(AESL_proc_cnter);
        sensitive << AESL_clock.pos();



        SC_METHOD(AESL_proc_buffer_output);
        sensitive << AESL_clock.pos();

#if defined(AESL_APATB_ALDEC)
        SC_METHOD(AESL_proc_clock_bool);
        sensitive << AESL_clock;
#endif

    }

};


void AUTOTB_TOP::AESL_proc_buffer_output()
{
    if (0) {
        AESL_BUFF_ap_start_out.write(sc_logic());
    }
    else if (1) {
        AESL_BUFF_ap_start_out.write(ap_start_out.read());
    }

}


void AUTOTB_TOP::AESL_proc_cnter()
{
    AESL_mLatCnter ++;
}


void AUTOTB_TOP::AESL_proc_tv_in()
{
    int wait_i;
    AESL_start.write(SC_LOGIC_0);
    AESL_ce.write(SC_LOGIC_1);
    AESL_continue.write(SC_LOGIC_1);
    AESL_reset.write(SC_LOGIC_1);
    wait();
    wait(4);
    AESL_reset.write(SC_LOGIC_0);

    wait();
    wait(10, SC_PS);
    AESL_start.write(SC_LOGIC_1);
    while (AESL_done_cnt < AUTOTB_TRANSACTION_NUM) {
        wait();
        wait(10, SC_PS);
    }
    AESL_start.write(SC_LOGIC_0);

}


void AUTOTB_TOP::AESL_proc_tv_out()
{
    wait();
    wait(4);

    while (1) {

        while (AESL_start.read() != SC_LOGIC_1)  wait();
        wait();

        unsigned AESL_latency = 0;
        bool AESL_timeout = false;
        if (true
            && AESL_mFinishTvOut_ap_start_out
        ) {
            break;
        }

    }

    wait(10, SC_PS);
    sc_stop();
}


void AUTOTB_TOP::AESL_proc_mlatcnterin()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_mLatCnterInIdx = 0;
    }
    else if (AESL_mLatCnterInIdx == AESL_mLatCnterOutIdx && AESL_start.read() == SC_LOGIC_1 && AESL_mLatCnterInIdx < AUTOTB_TRANSACTION_NUM + 1 ) {
        AESL_mLatCnterIn[AESL_mLatCnterInIdx++] = AESL_mLatCnter;
    }
}

void AUTOTB_TOP::AESL_proc_mlatcnterout()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_mLatCnterOutIdx = 0;
        AESL_mLatCnterOut[AESL_mLatCnterOutIdx] = AESL_mLatCnter + 1;
        AESL_done_cnt = 0;
    }
    else if (AESL_done.read() == SC_LOGIC_1 && AESL_mLatCnterOutIdx < AUTOTB_TRANSACTION_NUM + 1 ) {
        AESL_mLatCnterOut[AESL_mLatCnterOutIdx++] = AESL_mLatCnter;
        AESL_done_cnt ++;
    }
}

void AUTOTB_TOP::AESL_proc_calculate_performance()
{
    wait();
    wait(4);

    while (1) {

        wait();

        bool AESL_timeout = false;
        if (true
            && AESL_mFinishTvOut_ap_start_out
        ) {
            break;
        }

    }
    wait (1 , SC_PS);
    //////calculate latency/throught
    int AESL_tmp_latthistime;
    int AESL_tmp_lattotal = 0;
    int AESL_tmp_latmax = 0;
    int AESL_tmp_latmin = 0x7fffffff;
    int AESL_tmp_lataver;
    int AESL_tmp_thrthistime;
    int AESL_tmp_thrtotal = 0;
    int AESL_tmp_thrmax = 0;
    int AESL_tmp_thrmin = 0x7fffffff;
    int AESL_tmp_thraver;

        AESL_tmp_latmax  = 0;
        AESL_tmp_latmin  = 0;
        AESL_tmp_lataver = 0;
        AESL_tmp_thrmax  = 0;
        AESL_tmp_thrmin  = 0;
        AESL_tmp_thraver = 0;

    ofstream AESL_tmp_result_file(AUTOTB_LAT_RESULT_FILE);
    AESL_tmp_result_file << "$MAX_LATENCY = \"" << AESL_tmp_latmax << "\"\n";
    AESL_tmp_result_file << "$MIN_LATENCY = \"" << AESL_tmp_latmin << "\"\n";
    AESL_tmp_result_file << "$AVER_LATENCY = \"" << AESL_tmp_lataver << "\"\n";
    AESL_tmp_result_file << "$MAX_THROUGHPUT = \"" << AESL_tmp_latmax << "\"\n";
    AESL_tmp_result_file << "$MIN_THROUGHPUT = \"" << AESL_tmp_latmin << "\"\n";
    AESL_tmp_result_file << "$AVER_THROUGHPUT = \"" << AESL_tmp_lataver << "\"\n";
    AESL_tmp_result_file.close();
    ofstream AESL_tmp_result_trans_file(AUTOTB_PER_RESULT_TRANS_FILE);
    char s[100] = "";
    sprintf (s,"%20s%16s%16s\n","","latency","interval");
    AESL_tmp_result_trans_file << s ;
    for (int i = 0; i < AESL_mLatCnterOutIdx; i++) {
        sprintf (s,"transaction%8d:%16d%16d\n",i , 0, 0);
        AESL_tmp_result_trans_file << s ;
    }
    AESL_tmp_result_trans_file.close();


}
void AUTOTB_TOP::AESL_proc_ready_cnt()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_ready_cnt = 0;
    } else if (AESL_transaction_ready == 1 && AESL_ready_cnt <= AUTOTB_TRANSACTION_NUM) {
        AESL_ready_cnt ++;
    }
}
void AUTOTB_TOP::AESL_proc_initial_ready() {
    wait ();
    AESL_initial_ready = SC_LOGIC_0;
    while(AESL_reset.read() == SC_LOGIC_1)
    {
        wait ();
        wait (10, SC_PS);
    }
    wait ();
    AESL_initial_ready = SC_LOGIC_1;

    wait ();
    AESL_initial_ready = SC_LOGIC_0;
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_ready_delay() {
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
       AESL_ready_delay = SC_LOGIC_0;
    } else {
       AESL_ready_delay = AESL_ready;
    }
}

void AUTOTB_TOP::AESL_proc_done_delay() {
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
       AESL_done_delay.write(SC_LOGIC_0);
       AESL_done_delay2.write(SC_LOGIC_0);
    } else {
       AESL_done_delay.write(AESL_done.read());
       AESL_done_delay2.write(AESL_done_delay.read());
    }
}

void AUTOTB_TOP::AESL_proc_transaction_ready() {
    AESL_transaction_ready = AESL_initial_ready | AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_interface_done() {
    wait();
    AESL_interface_done = SC_LOGIC_0;
    while(AESL_reset.read() == SC_LOGIC_1)
    {
        wait();
        wait(10, SC_PS);
    }
    while (1) {
        wait (1, SC_PS);
        if (AESL_transaction_ready == 1 && AESL_ready_cnt > 1 && AESL_ready_cnt <= AUTOTB_TRANSACTION_NUM)
            AESL_interface_done = SC_LOGIC_1;
        else if(AESL_done_delay == 1 && AESL_done_cnt == AUTOTB_TRANSACTION_NUM)
            AESL_interface_done = SC_LOGIC_1;
        else
            AESL_interface_done = SC_LOGIC_0;
        wait();
    }
}

void AUTOTB_TOP::AESL_proc_transaction_ready_ap_start_enable () {
    AESL_transaction_ready_ap_start_enable = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_ap_start_enable () {
    AESL_transaction_done_ap_start_enable = AESL_done_delay;
}


void AUTOTB_TOP::AESL_proc_transaction_done_ap_start_out () {
    AESL_transaction_done_ap_start_out = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_ap_ready_in () {
    AESL_transaction_ready_ap_ready_in = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_ap_ready_in () {
    AESL_transaction_done_ap_ready_in = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_ap_done_in () {
    AESL_transaction_ready_ap_done_in = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_ap_done_in () {
    AESL_transaction_done_ap_done_in = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_ap_idle_in () {
    AESL_transaction_ready_ap_idle_in = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_ap_idle_in () {
    AESL_transaction_done_ap_idle_in = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_ap_status_out_V () {
    AESL_transaction_ready_ap_status_out_V = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_tv_in_ap_ready_in()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_ap_ready_in, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_ap_ready_in, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_ap_ready_in, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_ap_ready_in, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_ap_ready_in == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1> AESL_tempval =  AESL_token.c_str();
            ap_ready_in.write(AESL_tempval == "1"? SC_LOGIC_1 : SC_LOGIC_0);
            AESL_fh.read(AUTOTB_TVIN_ap_ready_in, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_ap_ready_in, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_ap_done_in()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_ap_done_in, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_ap_done_in, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_ap_done_in, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_ap_done_in, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_ap_done_in == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1> AESL_tempval =  AESL_token.c_str();
            ap_done_in.write(AESL_tempval == "1"? SC_LOGIC_1 : SC_LOGIC_0);
            AESL_fh.read(AUTOTB_TVIN_ap_done_in, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_ap_done_in, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_ap_idle_in()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_ap_idle_in, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_ap_idle_in, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_ap_idle_in, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_ap_idle_in, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_ap_idle_in == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1> AESL_tempval =  AESL_token.c_str();
            ap_idle_in.write(AESL_tempval == "1"? SC_LOGIC_1 : SC_LOGIC_0);
            AESL_fh.read(AUTOTB_TVIN_ap_idle_in, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_ap_idle_in, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_out_ap_start_out()
{
    wait();

    unsigned AESL_transIdx = 0;
    unsigned AESL_i;
    stringstream AESL_str;


    while (AESL_transIdx < AUTOTB_TRANSACTION_NUM) {
        wait();
        unsigned AESL_latency = 0;
        bool AESL_timeout = false;
        while (AESL_done.read() != SC_LOGIC_1) {
            AESL_latency++;
            wait();
        }


        int ap_start_out_tvout_size = LENGTH_ap_start_out ;
        AESL_str.str("");
        AESL_str <<"[[transaction]]" ;
        AESL_str << " " << AESL_transIdx << endl;
        AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
        AESL_transIdx ++;
        sc_lv<1> AESL_expected;
        if (!AESL_timeout) {
            if (1) {
                char AESL_szName[1024];
                sprintf(AESL_szName, "ap_start_out");;
                unsigned AESL_wlen =  strlen(AESL_szName);
                string AESL_sphd =  string(AESL_wlen, ' ');
                string argValStr = "X";
                if (ap_start_out_counter > 0 ) {
                    int i=0;
                    if (ap_start_out_counter < ap_start_out_tvout_size) {
                        for (i=0 ; i < ap_start_out_counter ; i++) {
                            if (!ap_start_out_output_vector[i].is_01()) {
                                AESL_str.str("");
                                AESL_str << ap_start_out_output_vector[i] << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            } else {
                                argValStr = ap_start_out_output_vector[i].to_char();
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            }
                        }
                        for (i=0 ; i < ap_start_out_tvout_size - ap_start_out_counter ; i++) {
                            AESL_str.str("");
                            AESL_str << "0" << endl;
                            AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                        }
                    } else {
                        for (i=0 ; i < ap_start_out_tvout_size ; i++) {
                            if (!ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size].is_01()) {
                                AESL_str.str("");
                                AESL_str << ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size] << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            } else {
                                argValStr = ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size].to_char();
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            }
                        }
                    }
                    ap_start_out_output_vector.clear();
                    ap_start_out_counter = 0;
                } else if (ap_start_out_counter == -1){
                      if (ap_start_out.read().is_01())
                          argValStr = ap_start_out.read().to_char();
                          if (argValStr == "X") {
                                AESL_str.str("");
                                AESL_str << ap_start_out.read() << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                          } else {
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                          }
                } else {
                } 
            }
            else if (AESL_BUFF_ap_start_out.read().is_01()) {
                char AESL_szName[1024];
                sprintf(AESL_szName, "ap_start_out");;
                unsigned AESL_wlen =  strlen(AESL_szName);
                string AESL_sphd =  string(AESL_wlen, ' ');
                string argValStr = "X";
                if (ap_start_out_counter > 0 ) {
                    int i=0;
                    if (ap_start_out_counter < ap_start_out_tvout_size) {
                        for (i=0 ; i < ap_start_out_counter ; i++) {
                            if (!ap_start_out_output_vector[i].is_01()) {
                                AESL_str.str("");
                                AESL_str << ap_start_out_output_vector[i] << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            } else {
                                argValStr = ap_start_out_output_vector[i].to_char();
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            }
                        }
                        for (i=0 ; i < ap_start_out_tvout_size - ap_start_out_counter ; i++) {
                            AESL_str.str("");
                            AESL_str << "0" << endl;
                            AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                        }
                    } else {
                        for (i=0 ; i < ap_start_out_tvout_size ; i++) {
                            if (!ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size].is_01()) {
                                AESL_str.str("");
                                AESL_str << ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size] << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            } else {
                                argValStr = ap_start_out_output_vector[i + ap_start_out_counter - ap_start_out_tvout_size].to_char();
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                            }
                        }
                    }
                    ap_start_out_output_vector.clear();
                    ap_start_out_counter = 0;
                } else if (ap_start_out_counter == -1){
                      if (AESL_BUFF_ap_start_out.read().is_01())
                          argValStr = AESL_BUFF_ap_start_out.read().to_char();
                          if (argValStr == "X") {
                                AESL_str.str("");
                                AESL_str << AESL_BUFF_ap_start_out.read() << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                          } else {
                                AESL_str.str("");
                                AESL_str << argValStr << endl;
                                AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
                          }
                } else {
                } 
            }
        }

            AESL_str.str("");
            AESL_str << "[[/transaction]]" << endl;
            AESL_fh.write(AUTOTB_TVOUT_ap_start_out_out_wrapc, AESL_str.str());
    }

    AESL_mFinishTvOut_ap_start_out = true;

    while (1) wait();
}


#if defined(AESL_APATB_EXPORT)
#endif

#if !defined(AESL_APATB_EXPORT)
int sc_main(int ap_argc, char* ap_argv[])
{
    sc_clock clk("clk", 10.000000,SC_NS,0.5,0,SC_NS,false);
    AUTOTB_TOP AUTOTB_TOP_INST("top");

    AUTOTB_TOP_INST.AESL_clock(clk); 

    sc_report_handler::set_actions( SC_ID_LOGIC_X_TO_BOOL_, SC_LOG);
    sc_report_handler::set_actions( SC_ID_VECTOR_CONTAINS_LOGIC_VALUE_, SC_LOG);
    sc_report_handler::set_actions( SC_ID_MORE_THAN_ONE_SIGNAL_DRIVER_, SC_DISPLAY | SC_ABORT);

    sc_report_handler::set_actions("/IEEE_Std_1666/deprecated", SC_DO_NOTHING);
    try {
        sc_start();
    } catch (const sc_report& ex) {
        AUTOTB_TOP_INST.AESL_mErrNo++;
        cout << "\n" << ex.what() << endl;
	  } catch (...) {
        AUTOTB_TOP_INST.AESL_mErrNo++;
	      cout << "\nSystemC unknown internal error.\n";
    }

    return ((AUTOTB_TOP_INST.AESL_mErrNo != 0)? 1: 0);
}
#endif


#ifdef AESL_APATB_EXPORT
SC_MODULE_EXPORT(apatb_ap_ctl_handler_top);
#endif

